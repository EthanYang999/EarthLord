# Day 18：上传云端 + 领地展示

## 三层架构视角下的逻辑剖析

> 给小白上课专用版 - 让云端同步变得简单！
> 基于三层架构，用大白话把逻辑讲清楚

---

## 🎯 今天要做什么？

想象一下，你在末日世界中终于圈好了第一块领地：

昨天我们实现了：闭环 → 验证规则 → 圈地成功！

但是...末日幸存者联盟发来了紧急通知：

**通知1：** "你的领地只存在手机里，手机丢了地就没了！"
**通知2：** "其他玩家根本看不到你已经占了这块地！"
**通知3：** "没有在联盟登记的领地，不受保护！"

所以今天要实现云端同步：

1. **上传领地**：把验证通过的领地数据上传到云端数据库
2. **拉取领地**：从云端加载所有玩家的领地数据
3. **地图显示**：在地图上绘制所有领地（我的绿色，别人的橙色）
4. **领地管理**：在领地 Tab 查看和删除自己的领地

### 为什么要上传到云端？

因为这是多人游戏的基础啊！

- **数据持久化**：手机丢了、换了，领地数据还在
- **多人可见**：其他玩家能看到你的领地，知道这块地被占了
- **碰撞检测基础**：Day 19 要做的"领地重叠检测"需要知道所有人的领地

---

## 💬 提示词的颗粒度：云端功能怎么描述？

在开始之前，我们继续聊提示词的艺术：**描述云端功能时，应该说多细？**

### ❌ 错误示范（程序员思维）

```
我需要用 Supabase 的 insert 方法上传数据。
path 字段用 [[String: Double]] 格式存 JSON。
查询时用 eq("is_active", true) 过滤。
比较 userId 时要用 lowercased() 统一大小写...
```

这太技术了！普通人不知道 Supabase、JSON、lowercased 是什么。

### ✅ 正确示范（游戏设计者思维）

```
【场景背景】
我在做《地球新主》，一个末世户外圈地游戏。
玩家圈地成功后，领地数据目前只存在手机里。

【问题描述】
测试时发现几个问题：
- 卸载 App 重装后，之前圈的地全没了
- 别的玩家看不到我占的地，可能会重复占同一块
- 没法在不同设备上同步我的领地

【设计原因】
这是一个多人游戏，核心玩法是"抢地盘"。
如果每个人的领地只存本地，那就变成单机游戏了。
我们需要一个云端数据库，让所有人的领地都能互相看到。

【期望效果】
1. 圈地成功后，点击"确认登记"按钮上传到云端
2. App 启动时，自动加载所有玩家的领地
3. 在地图上显示所有领地：
   - 我的领地用绿色（表示"这是我的"）
   - 别人的领地用橙色（表示"这块被占了"）
4. 在领地 Tab 可以查看和删除自己的领地

【具体数值】
- 领地数据包括：坐标点数组、面积、创建时间
- 删除时要二次确认，防止误删
```

看到区别了吗？

**错误示范说的是"怎么存"**（Supabase、JSON、lowercased）
**正确示范说的是"要什么"**（场景、问题、原因、期望、数值）

### 好的需求描述应该包含

| 应该有   | 为什么                     |
| -------- | -------------------------- |
| 场景背景 | 让 AI 理解上下文           |
| 问题描述 | 说清楚现在有什么问题       |
| 设计原因 | 解释为什么要这样设计       |
| 期望效果 | 什么算成功、显示什么       |
| 具体数值 | 数据格式、交互细节         |

| 不需要有   | 为什么           |
| ---------- | ---------------- |
| 数据库语法 | AI 会自己写      |
| JSON 格式  | AI 会自己设计    |
| API 调用   | AI 会自己处理    |
| 大小写处理 | AI 会自己注意    |

### 一句话总结

**你是游戏设计师，不是后端工程师。**
**说清楚数据要存哪、谁能看到、怎么显示。**
**让 AI 去操心数据库和网络请求。**

---

## 📚 三层架构 - 云端功能视角

还记得三层架构吗？今天我们从云端功能的角度再看一遍：

```
┌─────────────────────────────────────────┐
│  三楼：界面层（你看到的）                  │
│  - "确认登记"按钮                        │
│  - 地图上的绿色/橙色多边形                │
│  - 领地列表和详情页                       │
├─────────────────────────────────────────┤
│  二楼：逻辑层（点了之后发生什么）          │
│  - 上传领地到云端                         │
│  - 从云端拉取领地                         │
│  - 判断哪些是我的、哪些是别人的            │
├─────────────────────────────────────────┤
│  一楼：数据层（数据存在哪）               │
│  - 本地：territories 数组                │
│  - 云端：Supabase territories 表         │
│  - 模型：Territory 结构体                │
└─────────────────────────────────────────┘
```

**今天的重点**：
- **一楼**：设计数据模型和数据库表
- **二楼**：实现上传/拉取/删除逻辑
- **三楼**：地图绘制和领地管理界面

---

## 🎬 完整数据流向 - 从上传到显示

让我们跟着数据的脚步，走一遍完整的流程：

### 流程1：上传领地

```
用户圈地成功，点击「确认登记」按钮
    ↓
┌─────────────────────────────────────────────┐
│ 三楼：界面层                                 │
│ 用户点击「确认登记」按钮                     │
│     ↓                                        │
│ 调用 uploadCurrentTerritory()               │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 二楼：逻辑层                                 │
│ TerritoryManager.uploadTerritory()          │
│     ↓                                        │
│ 【步骤1】再次检查验证状态                    │
│     ↓                                        │
│ 【判断】territoryValidationPassed == true？ │
│     ↓ 否                                     │
│ 【失败】提示"验证未通过，无法上传"           │
│     ↓ 是                                     │
│ 【为什么要再检查？】                          │
│ - 防止绕过验证直接上传                       │
│ - 用户可能通过其他方式调用上传               │
├─────────────────────────────────────────────┤
│ 【步骤2】准备上传数据                        │
│     ↓                                        │
│ 坐标转 path JSON: [{"lat": x, "lon": y}]    │
│ 坐标转 WKT 多边形格式（给 PostGIS 用）       │
│ 计算边界框 bbox（优化查询性能）              │
│     ↓                                        │
│ 【为什么要转格式？】                          │
│ - path JSON：方便前端解析和显示              │
│ - WKT：数据库空间计算用（Day 19 碰撞检测）   │
│ - bbox：快速筛选附近的领地                   │
├─────────────────────────────────────────────┤
│ 【步骤3】调用 Supabase API 上传              │
│     ↓                                        │
│ insert into territories (...)               │
│     ↓ 成功                                   │
│ 返回上传成功                                 │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 一楼：数据层                                 │
│ 云端数据库新增一条领地记录                   │
│ user_id = 当前用户                          │
│ path = [{"lat": 31.2, "lon": 121.4}, ...]  │
│ area = 6800                                 │
│ is_active = true                            │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 三楼：界面层                                 │
│ 显示"领地登记成功！"提示                     │
│ 调用 stopPathTracking() 停止追踪            │
│ 刷新地图显示新领地                           │
└─────────────────────────────────────────────┘
```

### 流程2：加载并显示领地

```
App 启动或刷新
    ↓
┌─────────────────────────────────────────────┐
│ 三楼：界面层                                 │
│ MapTabView.onAppear                         │
│     ↓                                        │
│ 调用 loadTerritories()                      │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 二楼：逻辑层                                 │
│ TerritoryManager.loadAllTerritories()       │
│     ↓                                        │
│ 【步骤1】查询云端数据库                      │
│     ↓                                        │
│ SELECT * FROM territories                   │
│ WHERE is_active = true                      │
│     ↓                                        │
│ 【为什么过滤 is_active？】                   │
│ - 删除的领地标记为 false，不再显示          │
│ - 软删除，保留历史数据                       │
├─────────────────────────────────────────────┤
│ 【步骤2】解析返回数据                        │
│     ↓                                        │
│ JSON → [Territory] 数组                     │
│     ↓                                        │
│ 【常见坑：解析失败】                          │
│ - 数据库字段和模型字段名不匹配               │
│ - 可选字段没标记为 Optional                  │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 一楼：数据层                                 │
│ territories: [Territory] = 加载的领地数组   │
│ 存储在 @State 变量中                        │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 三楼：界面层 - 地图绘制                      │
│ MapViewRepresentable.drawTerritories()      │
│     ↓                                        │
│ 【步骤1】遍历每个领地                        │
│     ↓                                        │
│ for territory in territories {              │
│     coords = territory.toCoordinates()      │
│     ↓                                        │
│ 【步骤2】坐标转换（中国大陆必须！）          │
│     ↓                                        │
│     coords = WGS84 → GCJ02                  │
│     ↓                                        │
│ 【为什么要转换？】                            │
│ - 数据库存的是 GPS 原始坐标（WGS-84）        │
│ - 中国地图用的是偏移坐标（GCJ-02）           │
│ - 不转换会偏移 100-500 米                    │
│     ↓                                        │
│ 【步骤3】判断是我的还是别人的                │
│     ↓                                        │
│ ⚠️ 关键：比较时要统一大小写！                │
│ territory.userId.lowercased()               │
│     == currentUserId?.lowercased()          │
│     ↓                                        │
│ 【为什么要 lowercased？】                     │
│ - 数据库存的 UUID 是小写：337d8181-...       │
│ - iOS 的 uuidString 是大写：337D8181-...     │
│ - 直接比较会返回 false，自己的显示成橙色！   │
│     ↓                                        │
│ 【步骤4】设置颜色并绑定                       │
│     ↓                                        │
│ polygon.title = isMine ? "mine" : "others"  │
│ 我的 → 绿色填充                              │
│ 别人的 → 橙色填充                            │
│ }                                            │
└─────────────────────────────────────────────┘
```

---

## 🔍 深入二楼：逻辑层的核心知识点

现在我们放大看看二楼（逻辑层）的核心知识点。

### 知识点1：数据库表设计

#### 🎯 要解决什么问题？

设计一个表来存储领地数据，既要方便前端显示，又要支持后端空间计算。

#### 💡 提示词思维（小白怎么描述需求）

```
【场景背景】
我需要一个数据库表来存储玩家的领地数据。

【问题描述】
领地数据包括很多信息：
- 这块地是谁的？
- 边界坐标是什么？
- 面积多大？
- 什么时候圈的？

【设计原因】
1. 前端需要读取坐标来画多边形
2. 后端需要做空间计算（将来检测领地重叠）
3. 需要支持软删除（标记删除而不是真删）

【期望效果】
一个完整的领地表，包含所有需要的字段。
```

#### 📋 表结构设计

| 字段 | 类型 | 说明 | 为什么需要？ |
| ---- | ---- | ---- | ------------ |
| id | uuid | 主键 | 唯一标识每块领地 |
| user_id | uuid | 用户ID | 知道是谁的领地 |
| name | text (nullable) | 领地名称 | 用户可以给领地起名 |
| path | jsonb | 坐标数组 | 前端画多边形用 |
| polygon | geography | PostGIS格式 | 后端空间计算用 |
| area | double | 面积(平方米) | 显示和排序用 |
| point_count | integer | 点数 | 调试和验证用 |
| is_active | boolean | 是否有效 | 软删除标记 |
| created_at | timestamptz | 创建时间 | 显示和排序用 |

**⚠️ 重要：name 字段必须是 nullable！**
因为上传时不强制命名，如果是 NOT NULL 会报错。

---

### 知识点2：WKT 格式

#### 🎯 什么是 WKT？

WKT（Well-Known Text）是一种文本格式，用来描述地理空间数据。

```
SRID=4326;POLYGON((经度1 纬度1, 经度2 纬度2, ..., 经度1 纬度1))
```

**关键点：**
- SRID=4326 表示使用 WGS-84 坐标系
- 经度在前，纬度在后（和 iOS 的 lat/lon 顺序相反！）
- 多边形必须闭合（首尾坐标相同）

#### 💡 常见错误

```swift
// ❌ 错误：iOS 习惯是 lat, lon
"POLYGON((\(lat1) \(lon1), ...))"

// ✅ 正确：WKT 是 lon, lat
"POLYGON((\(lon1) \(lat1), ...))"
```

---

### 知识点3：UUID 大小写问题（重要！）

#### 🎯 要解决什么问题？

判断一块领地是我的还是别人的，需要比较 userId。

#### 💡 常见坑

**症状**：自己的领地显示成橙色（别人的颜色）

**原因**：
- 数据库存储的 user_id 是**小写**：`337d8181-...`
- iOS 的 `uuidString` 返回**大写**：`337D8181-...`
- 直接用 `==` 比较会返回 `false`

#### 🔧 解决方案

```swift
// ❌ 错误写法
if territory.userId == currentUserId { ... }

// ✅ 正确写法
let isMine = territory.userId.lowercased() == currentUserId?.lowercased()
```

---

### 知识点4：验证通过才能上传

#### 🎯 要解决什么问题？

确保只有合法的领地才能进入数据库。

#### 💡 设计原则

```
验证失败 → 不显示上传按钮
验证通过 → 显示「确认登记」按钮 → 点击上传
上传成功 → 停止追踪 → 刷新地图
```

**⚠️ 关键：上传成功后必须调用 `stopPathTracking()`！**

**为什么？**
- 如果不停止，GPS 继续记录新点
- 可能再次触发验证
- 用户可以重复点击上传，导致数据重复

---

### 知识点5：坐标转换（中国大陆）

#### 🎯 要解决什么问题？

在中国大陆，地图和 GPS 使用不同的坐标系。

#### 💡 两种坐标系

| 坐标系 | 用在哪 | 特点 |
| ------ | ------ | ---- |
| WGS-84 | GPS原始数据、数据库存储 | 国际标准 |
| GCJ-02 | 中国地图显示（高德、苹果中国） | 加了偏移 |

**如果不转换会怎样？**
- 领地多边形会偏移 100-500 米
- 看起来像领地"飘"到了旁边

#### 🔧 解决方案

在显示领地时，把 WGS-84 坐标转成 GCJ-02：

```swift
// 显示前转换坐标
coords = coords.map { coord in
    CoordinateConverter.wgs84ToGcj02(latitude: coord.latitude, longitude: coord.longitude)
}
```

---

## 📦 一楼：数据存储层

前面讲了逻辑，但数据存在哪？一楼！

### 本地数据

| 数据名称 | 类型 | 作用 | 谁在用它？ |
| -------- | ---- | ---- | ---------- |
| **territories** | `[Territory]` | 已加载的领地列表 | 三楼读取用于地图绘制 |
| **myTerritories** | `[Territory]` | 我的领地列表 | 领地 Tab 显示用 |

### 云端数据

| 表名 | 字段 | 作用 |
| ---- | ---- | ---- |
| **territories** | id, user_id, path, area... | 存储所有玩家的领地 |

### Territory 模型

```swift
struct Territory: Codable, Identifiable {
    let id: String
    let userId: String          // 对应数据库 user_id
    let name: String?           // ⚠️ 可选，数据库允许为空
    let path: [[String: Double]]  // [{"lat": x, "lon": y}]
    let area: Double
    let pointCount: Int?        // ⚠️ 可选，防止解码失败
    let isActive: Bool?         // ⚠️ 可选，防止解码失败

    // 转换为坐标数组
    func toCoordinates() -> [CLLocationCoordinate2D] {
        return path.compactMap { point in
            guard let lat = point["lat"], let lon = point["lon"] else { return nil }
            return CLLocationCoordinate2D(latitude: lat, longitude: lon)
        }
    }
}
```

**⚠️ 为什么很多字段是 Optional？**
- 数据库返回的数据不一定包含所有字段
- 如果字段是 NOT Optional，缺失时会解码失败
- 加了 `?` 就算缺失也能正常解析

---

## 🎨 三楼：界面层的变化

### 地图绘制

#### 💡 提示词思维

```
【场景背景】
领地数据已经从云端加载到本地了。
现在需要在地图上显示这些领地。

【问题描述】
地图上看不到任何领地，只有空地图。

【设计原因】
玩家需要知道哪些地已经被占了，这是游戏的核心反馈。
用颜色区分"我的"和"别人的"，一眼就能分清。

【期望效果】
- 每块领地用多边形显示
- 我的领地：绿色半透明填充 + 绿色边框
- 别人领地：橙色半透明填充 + 橙色边框
- 颜色要明显但不遮挡地图

【具体数值】
- 填充透明度：25%
- 边框宽度：2pt
```

#### 🔧 参考实现

```swift
// 在 rendererFor overlay 中处理领地多边形
if let polygon = overlay as? MKPolygon {
    let renderer = MKPolygonRenderer(polygon: polygon)

    if polygon.title == "mine" {
        renderer.fillColor = UIColor.systemGreen.withAlphaComponent(0.25)
        renderer.strokeColor = UIColor.systemGreen
    } else if polygon.title == "others" {
        renderer.fillColor = UIColor.systemOrange.withAlphaComponent(0.25)
        renderer.strokeColor = UIColor.systemOrange
    }

    renderer.lineWidth = 2.0
    return renderer
}
```

### 领地管理页面

#### 💡 提示词思维

```
【场景背景】
玩家可能圈了很多块领地，需要一个地方管理它们。

【问题描述】
现在领地 Tab 是空的占位页面，看不到自己的领地。

【设计原因】
玩家需要：
- 知道自己有多少块领地、总面积多大（成就感）
- 查看每块领地的详细信息
- 删除不想要的领地

【期望效果】
1. 顶部显示统计：X 块领地，总面积 XXX m²
2. 列表显示每块领地的卡片（名称、面积、时间）
3. 点击进入详情页
4. 详情页可以删除领地（需要确认）

【具体数值】
- 下拉可以刷新
- 删除需要二次确认弹窗
```

---

## 🏗️ 三层架构的配合 - 完整案例

### 案例1：上传领地成功

**时间轴：**

```
用户圈地成功，验证通过，点击「确认登记」
    ↓
┌─────────────────────────────────────────┐
│ 三楼：用户点击按钮                        │
│ → 调用 uploadCurrentTerritory()          │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 二楼：准备数据并上传                      │
│ → 检查验证状态 ✓                         │
│ → 坐标转 JSON 格式                       │
│ → 坐标转 WKT 格式                        │
│ → 计算边界框                             │
│ → 调用 Supabase insert                   │
│ → 上传成功！                             │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 一楼：云端数据库新增记录                  │
│ territories 表 +1 条                     │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 三楼：显示结果并刷新                      │
│ → 提示"领地登记成功！"                   │
│ → 停止追踪                               │
│ → 重新加载领地                           │
│ → 地图显示新领地（绿色）                 │
└─────────────────────────────────────────┘
```

### 案例2：自己的领地显示成橙色（常见 Bug）

**时间轴：**

```
App 启动，加载领地
    ↓
┌─────────────────────────────────────────┐
│ 二楼：从云端拉取领地                      │
│ → 获取到 3 块领地                        │
│ → 其中 1 块是自己的                      │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 三楼：绘制领地时判断颜色                  │
│     ↓                                    │
│ 数据库返回：userId = "337d8181-..."      │
│ iOS 获取：currentUserId = "337D8181-..." │
│     ↓                                    │
│ ❌ 直接比较："337d8181" == "337D8181"    │
│ → 返回 false                             │
│ → 判断为"不是我的"                       │
│ → 设置橙色！                             │
└─────────────────────────────────────────┘
    ↓
结果：自己的领地显示成橙色 😱
```

**修复后：**

```
┌─────────────────────────────────────────┐
│ 三楼：绘制领地时判断颜色                  │
│     ↓                                    │
│ ✅ 统一小写比较：                         │
│ "337d8181".lowercased()                  │
│     == "337D8181".lowercased()           │
│ → "337d8181" == "337d8181"               │
│ → 返回 true                              │
│ → 判断为"是我的"                         │
│ → 设置绿色！✓                            │
└─────────────────────────────────────────┘
```

---

## ❌ 常见问题排查

| 问题 | 原因 | 解决方案 |
| ---- | ---- | -------- |
| 上传失败：name 字段报错 | name 是 NOT NULL，但没传值 | 数据库改成 nullable |
| 加载领地失败：数据缺失 | 模型字段和数据库不匹配 | 检查 CodingKeys，加 Optional |
| 领地不显示在地图上 | 没调用 drawTerritories | 检查 updateUIView |
| 领地位置偏移几百米 | 没做 WGS-84 → GCJ-02 转换 | 显示前转换坐标 |
| **自己的领地显示橙色** | **UUID 大小写不匹配** | **用 lowercased() 比较** |
| 验证失败却能上传 | 上传前没检查验证状态 | 加 guard 检查 |
| 上传后能重复点击 | 没调用 stopPathTracking | 上传成功后停止追踪 |
| 外键约束失败 | profiles 表没有对应记录 | 补全 profiles 或去掉外键 |

---

## 🎓 小白也能懂的总结

### 核心思想：本地 ↔ 云端

```
上传：本地数据 → 格式转换 → 云端数据库
拉取：云端数据库 → 解析 → 本地数组 → 地图显示
删除：云端数据库标记 is_active = false
```

### 今天学了什么？

1. **云端存储**：为什么要上传到云端
   - 数据持久化、多人可见、支持碰撞检测

2. **数据库设计**：territories 表结构
   - path 存 JSON 给前端用，polygon 存 WKT 给后端用

3. **WKT 格式**：经度在前，纬度在后
   - 和 iOS 的 lat/lon 顺序相反

4. **UUID 大小写**：比较时用 lowercased()
   - 不然自己的领地会显示成别人的颜色

5. **坐标转换**：中国大陆要做 WGS-84 → GCJ-02
   - 不然领地会偏移几百米

6. **上传流程**：验证通过 → 确认登记 → 停止追踪
   - 防止验证失败的数据进数据库，防止重复上传

---

## 📌 金句收藏

> "云端存储是多人游戏的基础——你的领地只有别人看得到，才算真的占了！"

> "UUID 大小写是个隐藏坑——数据库小写，iOS 大写，直接比较会翻车！"

> "WKT 是经度在前、纬度在后——和 iOS 习惯相反，写错了数据就存到南极去了！"

> "验证通过才能上传，上传成功要停追踪——这两个检查缺一不可！"

---

## 🚀 下节课预告

**Day 19：多人碰撞检测**

将实现：

1. **实时碰撞检测**：圈地过程中检测是否与他人领地重叠
2. **预警系统**：靠近他人领地时震动提醒
3. **服务端校验**：使用 PostGIS ST_Intersects 函数

你圈的地，会不会和别人的领地重叠？咱们下节课见！

---

## 附录A：Day 18 关键代码位置速查表

| 功能 | 文件 | 函数/属性 | 层级 | 作用 |
| ---- | ---- | -------- | ---- | ---- |
| 领地模型 | `Territory.swift` | `Territory` | 一楼 | 数据结构定义 |
| 上传领地 | `TerritoryManager.swift` | `uploadTerritory()` | 二楼 | 上传到云端 |
| 拉取领地 | `TerritoryManager.swift` | `loadAllTerritories()` | 二楼 | 从云端加载 |
| 删除领地 | `TerritoryManager.swift` | `deleteTerritory()` | 二楼 | 软删除 |
| 坐标转JSON | `TerritoryManager.swift` | `coordinatesToPathJSON()` | 二楼 | 格式转换 |
| 坐标转WKT | `TerritoryManager.swift` | `coordinatesToWKT()` | 二楼 | 格式转换 |
| 绘制领地 | `MapViewRepresentable.swift` | `drawTerritories()` | 三楼 | 地图显示 |
| 领地列表 | `TerritoryTabView.swift` | `body` | 三楼 | 管理界面 |
| 领地详情 | `TerritoryDetailView.swift` | `body` | 三楼 | 详情页面 |

---

## 附录B：完整文件结构

```
项目名/
├── Models/
│   └── Territory.swift           ← Day 18 新建
├── Managers/
│   ├── LocationManager.swift
│   ├── TerritoryManager.swift    ← Day 18 新建
│   └── CoordinateConverter.swift
├── Views/
│   ├── Map/
│   │   └── MapViewRepresentable.swift  ← Day 18 修改（添加领地绘制）
│   ├── Tabs/
│   │   ├── MapTabView.swift      ← Day 18 修改（添加上传按钮）
│   │   └── TerritoryTabView.swift ← Day 18 重写
│   └── Territory/
│       └── TerritoryDetailView.swift  ← Day 18 新建
└── ...
```

---

## 附录C：Day 18 完整提示词示例

**如果你是一个游戏设计小白，想让 AI 帮你实现 Day 18 的全部功能，你可以这样说：**

```
【场景背景】
我在做《地球新主》，一个末世题材的户外圈地游戏。
玩家在现实世界中步行圈地，占领土地。

昨天我们实现了圈地验证：闭环 + 最小面积 + 不能自交。
验证通过后会显示绿色成功横幅。

但现在领地数据只存在手机里，我需要把它上传到云端。

【问题描述】
目前的问题：
- 卸载 App 后领地数据就没了
- 别的玩家看不到我已经占的地
- 没法在领地 Tab 管理自己的领地

【设计原因】
这是一个多人游戏，核心是"抢地盘"。
如果领地只存本地，就变成单机游戏了。
我们需要云端存储，让所有人的领地互相可见。

【期望效果】

功能1：上传领地
- 圈地验证通过后，显示「确认登记」按钮
- 点击按钮，把领地数据上传到云端
- 上传成功后提示"登记成功"，然后停止追踪
- 验证失败的不能上传

功能2：加载并显示领地
- App 启动时自动加载所有玩家的领地
- 在地图上用多边形显示每块领地
- 我的领地用绿色，别人的用橙色
- 颜色要半透明，不遮挡地图

功能3：领地管理
- 在领地 Tab 显示我的领地列表
- 顶部显示统计：X 块领地，总面积 XXX m²
- 点击进入详情页，可以删除领地
- 删除需要确认弹窗

【具体数值】
- 领地数据：坐标数组、面积、创建时间
- 颜色透明度：25%
- 删除需要二次确认

【技术说明】
- 数据库用 Supabase
- 表名：territories
- 需要用到 PostGIS 扩展（存储空间数据）
```

**这个描述严格遵循五要素：**

| 要素 | 内容 |
| ---- | ---- |
| **场景背景** | 什么游戏、做到哪了、今天要做什么 |
| **问题描述** | 3 个具体问题 |
| **设计原因** | 多人游戏需要云端 |
| **期望效果** | 3 个功能的具体描述 |
| **具体数值** | 数据内容、颜色透明度、交互细节 |

**完全没有技术术语：**

- ❌ 不提 JSON 格式
- ❌ 不提 WKT
- ❌ 不提 lowercased
- ❌ 不提 MKPolygon
- ❌ 不提 CodingKeys

**AI 会帮你搞定所有技术细节。**

**你只需要当好游戏设计师：想清楚要什么效果、为什么这样设计。**

---

**愿你的领地遍布全球！** 🌍

**记住：云端存储是多人游戏的基石！** ☁️

**提示词的艺术：说清楚"存什么、给谁看、怎么显示"！** 💡
